--QUESTIONS--
--문제 전체 조회--
SELECT
    Q.QID, Q.TITLE, C.CATEGORY,
    NVL(S.SID, 0) AS SAVE_SID --코우얼레스
FROM
    QUESTIONS Q
JOIN
    CATEGORY C ON Q.CATEGORY = C.CGID
LEFT JOIN
    SAVE S ON S.QID = Q.QID AND S.LOGIN_ID = 'user'
WHERE Q.Q_ACCESS = 'T';

--COALESCE와 NVL 차이점
--둘다 NULL 값을 처리하기 위한 함수
-- COALESCE :
--여러 개의 인수를 받아 첫 번째로 NULL이 아닌 값을 반환합니다
--인수로 전달된 값들 중에서 NULL이 아닌 첫번째 값을 반환하며 모든 값이 NULL인 경우에는 NULL을 반환합니다
--COALESCE 함수는 ANSI 표준 SQL 함수이므로 대부분의 데이터베이스 시스템에서 사용할 수 있습니다
--NVL:
--NVL 함수는 Oracle 데이터베이스에서 사용되는 함수로 첫 번째 인수인 NULL인 경우 두 번째 인수를 반환합니다
--NVL 함수는 오직 두 개의 인수만을 받을 수 있으며 첫 번째 인수가 NULL인 경우에는 두 번째 인수를 반환합니다
--NVL 함수는 Oracle 데이터베이스에서만 사용 가능합니다.


--문제 상세 조회--
SELECT QID,TITLE,ANSWER_A,ANSWER_B,EXPLANATION,CATEGORY
FROM QUESTIONS WHERE QID=1;-- 질문 PK로 질문 상세 내용을 받아온다

--save유무 추가하기--
SELECT Q.QID,Q.TITLE,Q.ANSWER_A,Q.ANSWER_B,Q.EXPLANATION,C.CATEGORY,
COUNT(CASE WHEN A.ANSWER = 'A' THEN 1 END) AS COUNT_A, 
COUNT(CASE WHEN A.ANSWER = 'B' THEN 1 END) AS COUNT_B,
NVL(S.SID, 0) AS SAVE_SID
FROM QUESTIONS Q
JOIN ANSWERS A ON A.QID=Q.QID
JOIN CATEGORY C ON Q.CATEGORY = C.CGID
LEFT JOIN
    SAVE S ON S.QID = Q.QID AND S.LOGIN_ID = 'user'
WHERE Q.QID=1
GROUP BY Q.QID, Q.TITLE, Q.ANSWER_A, Q.ANSWER_B, Q.EXPLANATION, C.CATEGORY,S.SID;

--문제 생성--
INSERT INTO QUESTIONS (QID, WRITER, TITLE, ANSWER_A, ANSWER_B, EXPLANATION,CATEGORY,Q_ACCESS) 
VALUES((SELECT NVL(MAX(QID),0) + 1 FROM QUESTIONS),'user','어느것','자장면','짬뽕','어느게 맛있음',1,'F');

INSERT INTO QUESTIONS (QID, WRITER, TITLE, ANSWER_A, ANSWER_B, EXPLANATION,CATEGORY,Q_ACCESS) 
VALUES((SELECT NVL(MAX(QID),0) + 1 FROM QUESTIONS),'user','어느것','부먹','찍먹','어느게 맛있음',1,'T');

INSERT INTO QUESTIONS (QID, WRITER, TITLE, ANSWER_A, ANSWER_B, EXPLANATION,CATEGORY,Q_ACCESS) 
VALUES((SELECT NVL(MAX(QID),0) + 1 FROM QUESTIONS),'user','평생 안 먹을 음식','마라탕','떡볶이','골라봐',1,'T');

SELECT * FROM QUESTIONS;

--문제 수정-- --문제 승인-- 합치는게 나을듯? 관리자가 올릴때 내용도 수정해야하는데? 
UPDATE QUESTIONS 
SET TITLE='어떻게 먹을래?',ANSWER_A='부먹',ANSWER_B='찍먹',EXPLANATION='어느게 맛있음',CATEGORY=1,Q_ACCESS='T' 
WHERE QID=1;

UPDATE QUESTIONS SET Q_ACCESS ='T' WHERE QID=1;

--문제 삭제--
DELETE FROM QUESTIONS WHERE QID=1;

--문제 승인 필요 지문 조회--
SELECT Q.QID,Q.TITLE,C.CATEGORY 
FROM QUESTIONS Q
JOIN CATEGORY C ON Q.CATEGORY =C.CGID
WHERE Q_ACCESS='F';


--문제 랜덤 생성 SAVE o--
--V1--
SELECT CASE 
           WHEN EXISTS (SELECT SID FROM SAVE WHERE LOGIN_ID='user') THEN 1
           ELSE 0
       END AS SAVE_RESULT,
       QID, TITLE, ANSWER_A, ANSWER_B, WRITER, EXPLANATION, C.CATEGORY
FROM (SELECT * FROM QUESTIONS ORDER BY DBMS_RANDOM.VALUE) Q
JOIN CATEGORY C
ON Q.CATEGORY = C.CGID
WHERE ROWNUM = 1 AND Q_ACCESS='T';

--V2-
--변경 찜이 있으면 SID 반환 없으면 0을 반환 --
--EXISTS절은 단순히 조건을 만족하는 레코드가 있는지 여부만을 확인하면 되기 때문에 SID 컬럼 대신에 1을 선택하도록 수정하였습니다
--이렇게하면 EXISTS절은 단순히 조건을 만족하는 레코드의 존재 여부만을 확인하므로 성능을 향상시킬 수 있습니다
SELECT 
    CASE 
        WHEN EXISTS (SELECT 1 FROM SAVE WHERE LOGIN_ID='user') 
        THEN (SELECT SID FROM SAVE WHERE LOGIN_ID='user')
        ELSE 0
    END AS SAVE_RESULT,
    QID, TITLE, ANSWER_A, ANSWER_B, WRITER, EXPLANATION, C.CATEGORY
FROM 
    (SELECT * FROM QUESTIONS ORDER BY DBMS_RANDOM.VALUE) Q
JOIN 
    CATEGORY C ON Q.CATEGORY = C.CGID
WHERE 
    ROWNUM = 1 AND Q_ACCESS='T';

--V3--
-- 변경 : 위 SQL문은 EXISTS절과 서브쿼리를 두번 사용하므로 성능 면에서 좋지 않다
--COALESCE 함수를 사용하여 SQL문을 만들어었을때 서브쿼리를 한번만 사용하므로 성능 면에서 효율 적일수 있다
 SELECT COALESCE(S.SID, 0) AS SAVE_RESULT,
       Q.QID, Q.TITLE, Q.ANSWER_A, Q.ANSWER_B, Q.WRITER, Q.EXPLANATION, C.CATEGORY
FROM 
    (SELECT QID,TITLE,ANSWER_A,ANSWER_B,WRITER,EXPLANATION,CATEGORY,Q_ACCESS FROM QUESTIONS ORDER BY DBMS_RANDOM.VALUE) Q
JOIN 
    CATEGORY C ON Q.CATEGORY = C.CGID
LEFT JOIN
    SAVE S ON S.QID = Q.QID AND S.LOGIN_ID = 'user'
WHERE ROWNUM = 1 AND  Q.Q_ACCESS = 'T';
    

--ANSWERS--
--답변 저장--
INSERT INTO ANSWERS (AID,QID,LOGIN_ID,ANSWER)
VALUES ((SELECT NVL(MAX(AID),0) + 1 FROM ANSWERS),1,'user','A');

INSERT INTO ANSWERS (AID,QID,LOGIN_ID,ANSWER)
VALUES ((SELECT NVL(MAX(AID),0) + 1 FROM ANSWERS),1,'user','A');

--COMMENTS--
--댓글 생성--
INSERT INTO COMMENTS(CID,QID,LOGIN_ID,CONTENT)
VALUES ((SELECT NVL(MAX(CID),0) + 1 FROM COMMENTS),3,'user','안녕 난 현구야');

--댓글 조회(질문)--
SELECT C.CID,C.QID,C.LOGIN_ID,C.CONTENT,M.NAME
FROM COMMENTS C
LEFT OUTER JOIN MEMBER M ON C.LOGIN_ID =M.LOGIN_ID
WHERE C.QID=1;

--댓글 조회(유저)--
SELECT C.CID,C.QID,C.LOGIN_ID,C.CONTENT,M.NAME
FROM COMMENTS C
LEFT OUTER JOIN MEMBER M ON C.LOGIN_ID =M.LOGIN_ID
WHERE C.LOGIN_ID='user';

select * from COMMENTS;

--댓글 삭제--
DELETE FROM COMMENTS WHERE CID=1;
DELETE FROM COMMENTS;
--MEMBER--
--회원 상세 조회----회원가입 중복 체크--
SELECT LOGIN_ID,NAME,EMAIL,ADDRESS,GENDER,AGE,GRADE,MADMIN
FROM MEMBER WHERE LOGIN_ID='user';

--회원 탈퇴 D--
DELETE FROM MEMBER WHERE LOGIN_ID='user';

--회원 탈퇴 U--
UPDATE QUESTIONS Q
SET Q.WRITER=NULL
WHERE Q.WRITER='user';

UPDATE MEMBER M 
JOIN QUESTIONS Q ON Q.WRITER = M.LOGIN_ID
JOIN ANSWERS A ON A.LOGIN_ID = M.LOGIN_ID
JOIN COMMENTS C ON C.LOGIN_ID = M.LOGIN_ID
JOIN SAVE S ON S.LOGIN_ID = M.LOGIN_ID
JOIN SUPPORT SU ON SU.LOGIN_ID = M.LOGIN_ID
SET Q.WRITER = NULL, A.LOGIN_ID = NULL, C.LOGIN_ID = NULL, S.LOGIN_ID = NULL, SU.LOGIN_ID = NULL
WHERE M.LOGIN_ID = 'user';
--UPDATE 뒤에 여러 테이블을 나열할 수 없습니다


UPDATE QUESTIONS
SET WRITER = NULL
WHERE WRITER = 'user';

UPDATE ANSWERS
SET LOGIN_ID = NULL
WHERE LOGIN_ID = 'user';

UPDATE COMMENTS
SET LOGIN_ID = NULL
WHERE LOGIN_ID = 'user';

UPDATE SAVE
SET LOGIN_ID = NULL
WHERE LOGIN_ID = 'user';

UPDATE SUPPORT
SET LOGIN_ID = NULL
WHERE LOGIN_ID = 'user';


--로그인--
SELECT LOGIN_ID,GRADE,MADMIN FROM MEMBER WHERE LOGIN_ID='user' AND MPW='1234';
--회원 목록 조회--
SELECT LOGIN_ID,NAME,GRADE FROM MEMBER WHERE MADMIN='USER';
--회원가입--
INSERT INTO MEMBER (MID, LOGIN_ID, MPW, NAME, EMAIL, ADDRESS, GENDER, AGE,CELL_PHONE) 
VALUES((SELECT NVL(MAX(MID),0) + 1 FROM MEMBER),'user','1234','박현구','123@123','집','M',12,123);

INSERT INTO MEMBER (MID, LOGIN_ID, MPW, NAME, EMAIL, ADDRESS, GENDER, AGE,CELL_PHONE,MADMIN) 
VALUES((SELECT NVL(MAX(MID),0) + 1 FROM MEMBER),'admin','1234','박현구','123@123','집','M',12,123,'ADMIN');

--회원 정보 변경--
UPDATE MEMBER SET NAME='티모',EMAIL='QWE@QWE',ADDRESS='버섯' WHERE LOGIN_ID='USER';


SELECT m.MID, m.LOGIN_ID, m.MPW, m.NAME, m.EMAIL, m.ADDRESS, m.GENDER, m.AGE, m.GRADE, m.CELL_PHONE, s.RANKING
FROM 
    MEMBER m
LEFT JOIN (
    SELECT 
        LOGIN_ID, 
        RANK() OVER (ORDER BY TOTAL_AMOUNT DESC) AS RANKING
    FROM (
        SELECT 
            LOGIN_ID, 
            SUM(AMOUNT) AS TOTAL_AMOUNT 
        FROM 
            SUPPORT 
        GROUP BY 
            LOGIN_ID
    ) SUBQUERY
) s ON m.LOGIN_ID = s.LOGIN_ID
WHERE 
    m.LOGIN_ID = 'user';

    
 SELECT C.CID,C.QID,M.LOGIN_ID,C.CONTENT,M.NAME 
 FROM COMMENTS C LEFT OUTER JOIN MEMBER M ON C.LOGIN_ID =M.LOGIN_ID
 
 WHERE C.QID=?   
    
    
 
 

--SAVE--
--찜하기--
INSERT INTO SAVE (SID, QID,LOGIN_ID) 
VALUES((SELECT NVL(MAX(SID),0) + 1 FROM SAVE),3,'user');
--찜삭제(질문 pk,로그인 아이디)--
DELETE FROM SAVE WHERE QID=2 AND LOGIN_ID='USER';
--찜삭제(찜 pk)--
DELETE FROM SAVE WHERE SID=2;
--나의 문제 찜--
SELECT
    Q.QID, Q.TITLE, C.CATEGORY,S.SID
FROM SAVE S   

JOIN
    QUESTIONS Q ON S.QID = Q.QID 
 JOIN
    CATEGORY C ON Q.CATEGORY = C.CGID
WHERE Q.Q_ACCESS = 'T' AND S.LOGIN_ID = 'user';

SELECT 1 FROM SAVE WHERE LOGIN_ID='USER' AND QID=3;
select * from SAVE;

--SUPPORT--
--후원하기--
INSERT INTO SUPPORT (SUID, LOGIN_ID,AMOUNT) 
VALUES((SELECT NVL(MAX(SUID),0) + 1 FROM SUPPORT),'user',1000000000);
INSERT INTO SUPPORT (SUID, LOGIN_ID,AMOUNT) 
VALUES((SELECT NVL(MAX(SUID),0) + 1 FROM SUPPORT),'user',100);

--후원 목록 조회--
SELECT S.LOGIN_ID, SUM(S.AMOUNT) TOTAL, M.NAME
FROM SUPPORT S
JOIN MEMBER M ON S.LOGIN_ID = M.LOGIN_ID
GROUP BY S.LOGIN_ID, M.NAME;



--CATEGORY--
--카테고리 추가--
INSERT INTO CATEGORY (CGID, CATEGORY) 
VALUES((SELECT NVL(MAX(CGID),0) + 1 FROM CATEGORY),'19금');
--카테고리 목록--
SELECT CGID,CATEGORY FROM CATEGORY;
--카테고리 변경--
--카테고리 삭제--

SELECT S.SID, Q.TITLE, Q.QID,Q.WRITER FROM SAVE S JOIN QUESTIONS Q ON S.QID = Q.QID WHERE S.LOGIN_ID = 'user';


select * from MEMBER;

SELECT COUNT(1) FROM QUESTIONS WHERE Q_ACCESS='T';
SELECT SUM(AMOUNT) AS TOTAL FROM SUPPORT;

select * from SAVE where LOGIN_ID='user';













SELECT Q.QID,Q.TITLE,Q.ANSWER_A,Q.ANSWER_B,Q.EXPLANATION,C.CATEGORY,Q.CATEGORY AS CATEGORY_PK, COUNT(CASE WHEN A.ANSWER = 'A' THEN 1 END) AS COUNT_A,
COUNT(CASE WHEN A.ANSWER = 'B' THEN 1 END) AS COUNT_B, NVL(S.SID, 0) AS SAVE_SID FROM QUESTIONS Q JOIN ANSWERS A ON A.QID=Q.QID 
JOIN CATEGORY C ON Q.CATEGORY = C.CGID LEFT JOIN
SAVE S ON S.QID = Q.QID AND S.LOGIN_ID = ? WHERE Q.QID=1 GROUP BY Q.QID, Q.TITLE, Q.ANSWER_A, Q.ANSWER_B, Q.EXPLANATION, C.CATEGORY,S.SID,Q.CATEGORY;





